
알림 시스템(notification system)은 최근 많은 프로그램이 채택한 인기 있는 기능으로 여러 정보를 비동기적으로 제공한다.

# 1. 알림 유형별 지원 방안

### iOS 푸시 알림

iOS에서 푸시 알림을 보내기 위해서는 세 가지 컴포넌트가 필요하다.

<img width="449" height="98" alt="Image" src="https://github.com/user-attachments/assets/ad24bf98-be43-4427-8778-5ba57917861c" />

- 알림 제공자(provider) : 알림 요청(notification request)을 만들어 애플 푸시 알림 서비스(APNS : Apple Push Notification Service)로 보내는 주체
- 데이터
    - 단말 토큰(device token) : 알림 요청을 보내는 데 필요한 고유 식별자
    - 페이로드(payload) : 알림 내용을 담은 JSON 딕셔너리(dictionary)
- APNS : 애플이 제공하는 원격 서비스로, 푸시 알림을 iOS 장치로 보내는 역할을 담당
- iOS 단말(iOS device) : 푸시 알림을 수신하는 사용자 단말

### 안드로이드 푸시 알림

안드로이드 푸시 알림도 비슷한 절차로 전송된다. APNS 대신 FCM(FirebaseCloud Messaging)을 사용한다는 점만 다르다.

<img width="450" height="115" alt="Image" src="https://github.com/user-attachments/assets/c0476aea-7a80-416b-9dd7-7737c343f9a5" />

### **SMS** 메시지

SMS 메시지를 보낼 때는 보통 트윌리오(Twilio), 넥스모(Nexmo) 같은 제3 사업자의 서비스를 많이 이용한다.

<img width="431" height="105" alt="Image" src="https://github.com/user-attachments/assets/281898b6-4b43-4640-a7c3-4e7a6ff6b0c8" />

### 이메일

대부분의 회사는 고유 이메일 서버를 구축할 역량은 갖추고 있지만, 대부분의 경우가 상용 이메일 서비스를 이용한다. (센드그리드(Sendgrid) 메일침프(Mailchimp))

<img width="460" height="113" alt="Image" src="https://github.com/user-attachments/assets/5fa26ff7-9149-49f9-ae50-eb4fc8162009" />

# 2. 알림 전송 및 수신 시스템 설계

## 2.1 초기 시스템 설계

<img width="640" height="476" alt="Image" src="https://github.com/user-attachments/assets/c342aab0-9e91-478d-b535-01520906ca89" />

### 2.1.1 초기 시스템 컴포넌트

- 1 부터 N까지의 서비스
- 알림 시스템(notification system)
    - 서비스 1 ~ N에 알림 전송을 위한 API를 제공
    - 제3자 서비스에 전달할 알림 페이로드(payload) 생성
- 제3자 서비스(third party services)
    - 이 서비스들은 사용자에게 알림을 실제로 전달하는 역할

### 2.1.2 초기 설계의 문제점

- **SPOF (Single-Point-Of-Failure)**: **알림 시스템 서버가 단 하나**이기 때문에, 이 서버에 장애가 발생하면 전체 알림 기능이 마비된다.
- **규모 확장성 부족**: 사용자가 늘어나 알림 트래픽이 몰릴 경우, 단일 서버와 데이터베이스의 부하를 감당하기 어렵습니다. **서버 한 대로 모든 것을 처리하므로 수평적 확장이 불가능**
- **확장성 (Extensibility) 부족**: 새로운 알림 채널(예: 중국 시장의 Jpush)을 추가하거나 기존 서비스를 수정하기 어렵습니다. 또한, 알림을 처리하고 전송하는 데 많은 자원과 시간이 소요될 경우 시스템 전체가 느려질 수 있다.

## 2.2 개선된 시스템 설계 (Microservice Architecture)

초기 설계의 문제점을 해결하기 위해 **메시지 큐(Message Queue)**를 도입하여 각 컴포넌트를 분리한 **마이크로서비스 아키텍처(MSA) 구조**

### **2.2.1 개선 방향**

1. **데이터베이스와 캐시 분리**
2. **수평적 확장**: 알림 서버를 여러 대로 증설
3. **메시지 큐 도입**: 시스템 컴포넌트 간의 **강한 결합(Tight Coupling)을 끊기 위해** 메시지 큐를 사용

<img width="510" height="331" alt="Image" src="https://github.com/user-attachments/assets/ac6acd6e-eede-43fd-89cf-a18cdfe75fee" />

### 2.2.2 동작 방식

1. **API 호출**: 클라이언트가 API를 호출하여 알림 서버로 알림 전송을 요청
2. **메타데이터 조회**: 알림 서버는 캐시나 데이터베이스에서 사용자 정보, 단말기 토큰, 알림 설정 같은 메타데이터를 가져온다.
3. **큐(Queue)에 이벤트 추가**: 알림 서버는 전송할 알림에 맞는 이벤트(예: iOS 푸시 알림 이벤트)를 만들어 해당 **종류의 큐에 넣는다.**
4. **이벤트 처리**: **작업 서버(Worker)**가 메시지 큐에서 알림 이벤트를 꺼낸다.
5. **제3자 서비스로 전송**: 작업 서버는 해당 알림을 제3자 서비스(예: APNS)로 보낸다.
6. **최종 전송**: 제3자 서비스는 사용자 단말로 알림을 최종적으로 전송한다.

## 2.3 최종 상세 설계

### **2.3.1 개선 방향**

- 안정성
    - 데이터 손실 방지 : 알림로그 데이터베이스 유지를 통한 재시도 메커니즘
    - 알림 중복 전송 방지
- 알림 템플릿
- 알림 설정
    - 사용자의 알림 설정 알림 설정 테이블에 보관
- 전송률 제한
- 재시도 방법 : 재시도 전용 큐
- 푸시 알림과 보안
- 큐 모니터링 : metric(하나의 큐에 쌀인 알림의 개수)
- 이벤트 추적

<img width="499" height="291" alt="Image" src="https://github.com/user-attachments/assets/2b4454c2-d185-4cd7-b289-e737918ef789" />