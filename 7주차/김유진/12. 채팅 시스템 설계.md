- 채팅 앱의 요구사항을 확실하게 해 두는 것이 중요

## 1. 문제 이해 및 설계 범위 확정
- 1:1 채팅 앱/그룹 채팅 앱인지: 응답지연이 낮은 일대일 채팅
- 모바일 앱/웹 앱인지
- 처리해야 하는 트래픽 규모는 어느 정도인지: 5천 DAU 처리
- 그룹 채팅의 경우에 인원 제한이 있는지: 최대 100명까지 참여 가능
- 어떤 중요 기능이 있는지: 첨부파일 지원, 사용자 접속상태 표시, 텍스트 메시지, 푸시 알림
- 메세지 길이에 제한이 있는지
- 종단 간 암호화(end-to-end encryption) 지원해야 하는지
- 채팅 이력은 얼마나 오래 보관해야 하는지

## 2. 개략적 설계안 제시 및 동의 구하기
- 요구 사항
  - 클라이언트들로부터 메시지 수신
  - 메시지 수신자 결정 및 전달
  - 수신자가 접속 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관
- 메시지 송신 클라이언트 > 채팅 서비스 > 메시지 수신 클라이언트
  - 송신 클라이언트는 HTTP 프로토콜 사용
    - 클라이언트는 채팅 서비스에 HTTP 프로토콜로 연결한 다음 메세지를 보내 수신자에게 해당 메시지를 전달하라고 알린다
    - 채팅 서비스와의 접속에는 keep-alive 헤더 사용(연결 끊지 않고 계속 유지, TCP 핸드셰이크 횟수를 줄일 수 있다)
  - 수신 클라이언트
    - 폴링
      - 폴링은 클라이언트가 주기적으로 서버에게 새 메시지가 있느냐고 물어보는 방법
      - 폴링 비용은 폴링을 자주하면 할수록 올라감
      - 답해줄 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비
    - 롱 폴링
      - 클라이언트는 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지
      - 클라이언트는 새 메시지를 받으면 기존 연결을 종료, 서버에 새로운 요청을 보내여 모든 절차를 다시 시작
      - 메시지를 보내는 클라이언트와 수신 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수 있다
      - 서버 입장에서는 클라이언트가 연결 해제했는지 아닌지 알 방법이 없다
      - 메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때마다 주기적으로 서버에 다시 접속하기 때문에 비효율적
    - 웹소켓
      - 클라이언트가 연결 시작
      - 한번 맺어진 연결은 양방향
      - 처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거쳐 웹소켓 연결로 업그레이드
      - 항구적 연결이 만들어지고 나면 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있음
      - 방화벽있는 환경에서도 잘 동작: HTTPS 프로토콜이 사용하는 기본 포트번호를 그대로 쓰기 때문
- 개략적 설계안
  - 무상태 서비스
    - 로그인, 회원가입, 사용자 프로파일 표시 등 처리하는 전통적인 요청/응답 서비스
    - 로드밸런서(요청을 그 경로에 맞는 서비스로 정확하게 전달하게 해줌) 뒤에 위치
  - 상태유지 서비스
    - 채팅 서비스는 상태 유지가 필요
    - 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결을 유지해야 하기 때문
    - 클라이언트는 서버가 살아 있는 한 다른 서버로 연결을 변경하지 않음
  - 제3자 서비스 연동: 푸시 알림 서비스와의 통합 중요
  - 규모 확장성
  - 저장소
    - 데이터의 유형과 읽기/쓰기 연산의 패턴을 따져 관계영 데이터베이스/NoSQL 중에서 선택
      - 사용자 프로파일, 설정, 친구 목록 등 일반적 데이터 => RDB
      - 채팅 이력 => 키-값 저장소
  - 데이터 모델
    - 1:1 채팅을 위한 메시지 테이블: message_id를 기본키로 사용
    - 그룹 채팅을 위한 메시지 테이블: channel_id, message_id의 복합키를 기본 키로 사용
  - 메시지 ID
    - message_id의 값은 고유해야 한다
    - ID값은 정렬 가능해야 하며 시간 순서와 일치해야 한다(새로운 ID > 이전 ID)
    - RDBMS의 auto_imcrement, 전역적 64-bit 순서 번호 생성기, 지역적 순서 번호 생성기(유일성은 같은 그룹 안에서만 보증)

  - <img width="522" height="520" alt="image" src="https://github.com/user-attachments/assets/713093d5-e78d-430f-bbd5-c2c036090570" />


## 3. 상세 설계
### 서비스 탐색
- 클라이언트에게 가장 적합한 채팅 서버 추천
- 기준: 클라이언트의 위치, 서버의 용량
- 사용자 로그인 시도 > 로드밸런서가 요청을 API 서버 가운데 하나로 보냄 > 서비스 탐색 기능이 동작하여 최적의 채팅 서버를 찾는다 > 사용자는 채팅 서버와 웹소켓 연결을 맺음
### 메시지 흐름
#### 1:1 채팅 메시지 처리 흐름
<img width="466" height="436" alt="image" src="https://github.com/user-attachments/assets/0b8fde61-bcf1-4812-805f-8597c0e7797b" />

1. 사용자 A가 채팅 서버 1 로 메시지 전송
2. 채팅 서버 1 은 ID 생성기를 사용해 해당 메시지의 ID 결정
3. 채팅 서버 1 은 해당 메시지를 메시지 동기화 큐로 전송
4. 메시지가 키-값 저장소에 보관됨
5. (a) 사용자 B가 접속 중인 경우 메시지는 사용자 B가 접속 중인 채팅 서버(본 예제의 경우에는 채팅 서버 2)로 전송됨 (b) 사용자 B가 접속 중이 아니라면 푸시 알림 메시지를 푸시 알림 서버로 보냄
6. 채팅 서버 2는 메시지를 사용자 B에게 전송, 사용자 B와 채팅 서버 2 사이에는 웹소켓 연결이 있는 상태이므로 그것을 이용

#### 여러 단말 사이의 메시지 동기화
  - 각 단말에서 관측된 가장 최신 메시지의 ID를 추적하는 용도의 변수
  - 수신자 ID가 현재 로그인한 사용자 ID와 같다 & 보관된 메시지의 ID가 변수보다 크다
#### 소규모 그룹 채팅에서의 메시지 흐름
  - 사용자 1이 보낸 메시지가 사용자 2,3의 메시지 동기화 큐에 복사
  - 메시지 동기화 큐는 여러 사용자로부터 오는 메시지를 받을 수 있어야 함
### 접속상태 표시
- 사용자 로그인: 웹소켓 연결이 맺어지면 접속상태 서버는 A의 상태와 last_active_at 타임스탬프 값을 키-값 저장소에 보관
- 로그아웃
- 접속 장애: 박동 검사 -> 클라이언트는 박동 이벤트를 주기적으로 접속상태 서버로 보낸다, 마지막 이벤트를 받은 지 x초 이내에 또 다른 박동 이벤트 메시지를 받으면 접속상태를 계속 온라인으로 유지, 그렇지 않을 경우에는 오프라인으로 바꾼다
#### 상태 정보의 전송
- 상태정보 서버는 발행-구독 모델 사용
- 각각의 친구관계마다 채널을 하나씩 두는 것
- 그룹 크기가 작을 때는 효과적이지만 그룹 크기가 크면 성능 문제가 생긴다
- 사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 확인하게 하거나, 사용자 접속상태를 수동으로 하도록 유도
