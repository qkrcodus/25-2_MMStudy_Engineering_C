알림을 보내려면 모바일 단말 토큰, 전화번호, 이메일 주소 등의 정보가 필요
하다. 그림 10一7과 같이 사용자가 우리 앱을 설치하거나 처음으로 계정을 등록
하면 API 서버는 해당 사용자의 정보를 수집하여 데이터베 이스에 저장한다


• SPOF(Single-Point-Of-Failure)： 알림 서비스에 서버가 하나밖에 없다는 것
은, 그 서버에 장애가 생기면 전체 서비스의 장애로 이어진다는 뜻이다.

추가로 필요한 컴포넌트 및 고려사항: 
알림 템플릿, 
알림 설정, 
전송률 제한(rate limiting), 
재시도 메커니즘(retry mechanism), 
보안(security), 
큐에 보관된 알림에 대한 모니터 링과 이벤트 추적

알림 중복 전송 방지

보내야 할 알림이 도착하면 그 이벤트 ID를 검사하여 이전에 본 적이 있는이벤트인지 살핀다. (UID 아님)
중복된 이벤트라면 버리고, 그렇지 않으면 알림을 발송
한다.

알림 서버와 작업 서버의 구분 

알림 시스템에 추상화를 도입하여 메시지 형태와 무관하게 **메시지를 받는 역할(수신자)**과 **메시지를 보내는 역할(발신자)**을 분리하려면, 제시된 과정에서 이벤트 ID를 검사하는 단계 바로 직전에 추상화 계층을 두는 것이 가장 적절합니다.

추상화 도입 단계
메시지 생성 및 발신자 추상화: 알림을 보내야 하는 **원본 시스템(발신자)**은 특정 형태의 메시지(예: JSON, XML, 바이너리 데이터 등)를 생성하여, 메시지 전송을 담당하는 추상화된 인터페이스(예: Notifier, MessagePublisher)에 전달합니다. 이때 발신자는 메시지가 어떻게 처리되고 누구에게 전달될지 알 필요가 없습니다.

메시지 수신 및 처리 로직 추상화: 메시지 전송 인터페이스는 메시지를 받아 **알림 시스템(수신자)**으로 전달합니다. 알림 시스템은 메시지 형태에 관계없이 이벤트 ID를 추출하고 중복 여부를 확인하는 공통된 처리 로직을 수행합니다.

알림 발송 및 채널 추상화: 중복이 아닌 것으로 확인된 메시지는 실제 알림을 발송하는 또 다른 추상화된 인터페이스(예: NotificationChannel, SMSGateway, EmailSender)로 전달됩니다. 이 인터페이스는 메시지를 특정 채널(문자, 이메일, 앱 푸시 등)에 맞는 형태로 변환하여 최종 사용자에게 전달합니다.

왜 이 단계가 최적인가?
이 접근 방식은 발신자와 수신자 간의 의존성을 완전히 제거합니다.

발신자(Producer): 알림을 생성하는 쪽은 특정 알림 채널(예: 이메일, SMS)이나 메시지 형식에 대해 전혀 알 필요가 없습니다. 그저 '특정 이벤트가 발생했으니 알림을 보내라'는 추상적인 명령만 내리면 됩니다.

수신자(Consumer): 알림을 받는 쪽은 어떤 발신자가 보냈는지, 어떤 시스템에서 발생한 이벤트인지 신경 쓰지 않습니다. 오직 '이벤트 ID를 확인하고 중복이 아니면 알림을 발송한다'는 핵심 로직에만 집중할 수 있습니다.

이러한 분리를 통해 시스템은 확장성이 높아집니다. 새로운 알림 채널(예: 챗봇 알림)을 추가하거나, 메시지 형식이 변경되더라도 기존의 발신자 로직을 수정할 필요 없이, 추상화 계층만 수정하거나 확장하면 됩니다. 이를 통해 시스템의 유지보수와 유연성이 크게 향상됩니다.

메세지 시스템 

송신 클라이언트 - HTTP 프로토콜 -> 수신 클라이언트 

폴링 

주기적으로 서버에게 새 메세지를 물어보는 방법 

롱 폴링 (폴링 보다 효율적)

새 메세지 반환 or 타임아웃 까지 연결 유지 

여전히 비효율적 

웹 소켓 

클라이언트에게 비동기(async)적  메시지를 보낼때 가장 널리 사용하는 기술 