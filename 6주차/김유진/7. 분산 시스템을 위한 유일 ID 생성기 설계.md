## 1단계 문제 이해 및 설계 범위 확정
- ID의 특성
- 어떻게 커지는 값인지
- 어떻게 구성되어 있는지
- 시스템의 규모 정도

## 2단계 개략적 설계안 제시 및 동의 구하기
- 분산 시스템에서 유일성이 보장되는 ID를 만드는 방법
  - 다중 마스터 복제
    - 다음 ID의 값을 구할 때 현재 사용 중인 데이터베이스 서버 k만큼 증가
    - 규모 확장성 문제를 어느 정도 해결 가능(데이터베이스 수를 늘리면 초당 생산 가능 ID 수도 늘릴 수 있음)
    - 여러 데이터 센터에 걸쳐 규모를 늘리기 어려움
    - ID의 유일성 보장
    - 값이 시간 흐름에 맞추어 커지도록 보장할 수 없음
    - 서버를 추가/삭제할 때도 잘 동작하도록 만들기 어려움
  - UUID
    - UUID: 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수
    - UUID 값은 충돌 가능성이 지극히 낮다
    - 서버 간 조율 없이 독립적으로 생성 가능하다
    - 동기화 이슈 없음
    - 규모 확장이 쉬움
    - ID를 시간순으로 정렬할 수 없다
    - ID에 숫자가 아닌 값이 포함될 수 있다
  - 티켓 서버
    - auto_increment 기능을 갖춘 티켓 서버를 중앙 집중형으로 하나만 사용하는 것
    - 우직 숫자로만 구성된 ID를 쉽게 만들 수 있음
    - 구현하기 쉽고 중소 규모에 적합
    - 티켓 서버가 SPOF가 된다
  - 트위터 스노우플레이크 접근법
    - ID를 divide and conquer로 분할
    - 각 섹션을 나누고 섹션별로 비트 할당: 타임스탬프, 데이터센터 ID, 서버 ID, 일련번호

## 3단계 상세 설계(트위터 스노우플레이크)
- 데이터센터 ID, 서버 ID는 시스템 시작 시에 결정되며 일반적으로는 바뀌지 않는다
- 타임스탬프
  - 41비트를 차지
  - UTC 기원 시각을 타임스탬프 값으로 변환할 수 있다
  - 타임스탬프 > 십진수로 > 트위터 기원 시각을 더함 > 밀리초 값을 UTC 시각으로 변환
  - 41비트로 표현할 수 있는 타임스탬프의 최댓값은 약 69년에 해당
  - 69년이 지나면 기원 시각을 바꾸거나 ID 체계를 이전하여아 함
 
- 일련번호
  - 12비트이므로 $$2^{12}=4096$$ 개의 값을 가질 수 있다
  - 아던 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어낸 경우에만 0보다 큰 값을 갖게 된다
 
## 마무리
- 추가적으로 논의할 수 있는 부분
  - 시계 동기화: 서버들이 모두 같은 시계를 사용하지 않을 때
  - 각 섹션의 길이 최적화: 동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호 절의 길이를 줄이고 타임스탬프 절의 길이를 늘리는 것이 효과적
  - 고가용성: ID 생성기는 필수 불가결 컴포넌트이므로 아주 높은 가용성 제공
