지난 시간에 대규모 어플리케이션을 위해 데이터 베이스를 다중화 하는 방법을 살펴보았다.

주 - 부 관계 ( 주에만 쓰기 작업 있음 )이 아닌 다중 마스터 데이터베이스를 사용할때 발생할 수 있는 id 생성 문제에 대해 알아보자.

### 1. 분산 시스템을 위한 유일 ID 생성기 설계

auto_increment 속성이 설정된 관계형 DB의 기본 키를 쓰면 되지 않을까?

→ 분산 환경에서 데이터 베이스 서버 한대 x 

→ 여러 서버를 사용하는 경우엔 지연 시간을 낮추기 힘들 것임 

### 2. 적절한 질문을 통해 모호함을 없애며 문제를 이해하는 과정

Q ) ID 의 특성?

A ) ID 는 유일, 정렬 가능, 타임 스탬프 기반 ID, 64 비트 숫자로 구성

Q ) 시스템 규모?

A ) 초당 1000 ID 생성해야함 

### 3. 분산 시스템을 위한 유일 ID 생성기 - 방법 1 : 다중 마스터 복제

- DB의  auto_increment 기능 활용
- 다음 ID 값을 구할때 DB 서버 개수 만큼 증가 ( 1 → 3 → 5 .. )

<img width="528" height="248" alt="스크린샷 2025-08-17 오후 6 55 14" src="https://github.com/user-attachments/assets/2bf73d01-ed50-40e9-be7b-5682a8962664" />

하지만, 서버 추가나 삭제시 잘 동작하지 않고, ID 유일성은 보장되겠지만, 시간 흐름에 맞게 커지도록 보장할 순 없다. ( 서버별로 id 생성 요청 받은 순간 부터 id를 만들때까지 걸리는 시간이 다르다 )

### 3. 분산 시스템을 위한 유일 ID 생성기 - 방법 2 : UUID

- 유일하게 식별하기 위한 126비트 수
- 서버간 조율 없이 독립적으로 생성 가능하므로 동기화 이슈도 규모 확장도 쉽다
- 09c93e62-50b4-468d-bf8a-c07el04fbfb2 와 같은 형태를 띔

하지만, ID 가 128 비트로 길고, 시간순으로 정렬할 수 없으며 숫자가 아닌 값이 포함될 수 있다.

### 3. 분산 시스템을 위한 유일 ID 생성기 - 방법 3 : 티켓 서버

- auto_increment 기능을 갖춘 DB 서버 즉 티켓 서버를 집중형으로 하나만 사용하는 방식
- 유일성 보장 ID
- 구현이 쉽다

    <img width="680" height="304" alt="스크린샷 2025-08-17 오후 7 02 59" src="https://github.com/user-attachments/assets/1766ff98-5e25-42a5-b704-8444fed486c0" />


하지만, 티켓 서버가 SPOF 가 된다. 티켓 서버에 장애가 발생하면 이 서버를 이용하는 모든 시스템이 영향을 받는다. 이 이슈를 피하려면, 티켓서버를 여러대 준비해야하고, 이로 인해 동기화 같은 새로운 문제가 발생할 것이다. 

### 3. 분산 시스템을 위한 유일 ID 생성기 - 방법 4 : 트위터 스노플레이크

트위터는 snowflake 라고 불리는 독창적 ID 생성 기법을 사용한다. 

생성해야하는 ID 구조 

<img width="746" height="137" alt="스크린샷 2025-08-17 오후 7 09 54" src="https://github.com/user-attachments/assets/9d1b645d-0f22-4015-8b57-9645af16cbd0" />

- 데이터 센터와 서버 ID는 시스템이 시작되며 결정되고 시스템 운영중엔 변경되지 않는 값이다.
- 타임 스탬프와 일련 번호는 ID 생성기가 돌고 있는 중에 만들어 진다.
- 2^41 -1 밀리초 까지 표현 가능한 타임 스탬프는 약 69년동안 정상 작동한다.
- 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 일련번호는 0보다 큰 값을 갖게 된다.

### 4. 추가적으로 고려할 사항

1. 생성 서버가 모두 동일한 시계를 사용하지 않을 수 있다. → NTP ( network time protocol )로 해결
2. 동시성이 낮고 수명이 긴 애플리케이션이라면 → 일련 번호 길이의 섹션을 줄이고 타임 스탬프 길이를 늘리는 방법고 고려해볼만하다
3. ID 생성기는 아주 높은 가용성을 제공해야 한다.

---

### 1. 웹 크롤러 설계

검색 엔진에서 널리 쓴느 기술인 웹 크롤러는 웹에 새로 올라오거나 갱신된 콘텐츠를 찾아내는 것이 주된 목적이다. 

- 용도 1 : 검색 엔진 인덱싱
- 용도 2 : 웹 아카이빙
- 용도 3 : 웹 마이닝
- 용도 4 : 웹 모니터링

### 2. 웹 크롤러 기본적 알고리즘

1. URL 집합이 주어지면 해당 URL 이 가르키는 모든 웹 페이지를 다운로드한다.
2. 다운 받은 웹 페이지의 URL 을 추출한다.
3. 추출된 URL을 다운로드할 URL 목록에 추가하고 반복한다. 

### 3. 적절한 질문을 통해 모호함을 없애며 문제를 이해하는 과정

Q ) 크롤러의 주된 용도 ? 검색 엔진 인덱스 생성용 ? 데이터 마이닝? 그외 ?

A ) 크롤러는 검색 엔진 인덱싱, 매달 10억개의 웹 페이지, 새로 만들어지거나 수정된 웹 페이지도 고려해야함, 5년동안 저장, 중복된 컨텐츠는 무시 가능

1. 규모 확장성 → 병행성 고려해야 한다. 
2. 예의 → 수집 대상 웹 사이트에 짧은 시간동안 너무 많은 요청을 보내서는 안된다.
3. 확장성 → 새로운 형태의 콘텐츠를 지원하기 쉬워야 한다. 
4. 안정성 → 비정상적 입력이나 환경에 잘 대응해야 한다. 

<img width="709" height="538" alt="스크린샷 2025-08-17 오후 7 44 52" src="https://github.com/user-attachments/assets/de9842b8-eed9-4eec-92be-e32c0c3bef05" />

- 시작 URL : 크롤러가 가능한 많은 링크를 탐색할 수 있도록 하는 URL을 고르는게 바람직하다.
- 컨텐츠 파서 : 도메인 이름 변환기로 받은 IP 주소를 통해 웹 페이지를 다운로드하면 파싱과 검증 절차를 거쳐야한다 ( 이상한 웹 페이지는 저장 공간만 낭비하게 되기 때문 )
- 중복 콘텐츠 : 약 29%가량의 웬 페이지 콘텐츠가 중복이라는 연구 결과가 있다. 웹 페이지 해시 값을 비교하여 두 HTML 문서가 같은지 비교하면 효과적이다.
- 콘텐츠 저장소 : HTML 문서를 보관하는 곳이고 데이터 양이 너무 많은 경우 디스크, 인기 있는 콘텐츠는 메모리에 두어 접근 지연시간을 줄인다.
- URL 추출기 : HTML 문서에서 URL 링크를 골라내는 역할을 한다. 상대 경로는 모두 절대 경로로 변환한다.
    
   <img width="748" height="381" alt="스크린샷 2025-08-17 오후 7 53 09" src="https://github.com/user-attachments/assets/257de245-1ae4-4d2f-b870-76190bfdae97" />

- URL 저장소 : 이미 방문한 URL을 보관하는 저장소다.

### DFS와 BFS 중 어떤 것을 쓸 것인가

웹 : 단방향 그래프 ( 페이지 : 노드 , URL : 엣지 )

DFS : 그래프 크기가 클 경우 어느 정도 깊숙이 가게 될지 가늠하기 어렵다. 

따라서 웹 크롤러는 보통 BFS를 사용한다. 큐에 탐색할 URL을 넣는다. 

### BFS , 큐에 탐색할 URL을 넣는 구현법의 문제점 두가지

1. 예의 없는 크롤러 : 한 페이지에서 나오는 링크의 상당 수는 보통 같은 서버의 다른 페이지를 참조한다. 이로 인해 같은 호스트에 속한 만은 링크를 다운 받느라 바빠지게 된다. 
    
 <img width="649" height="473" alt="스크린샷 2025-08-17 오후 8 03 32" src="https://github.com/user-attachments/assets/95b7d22d-69c8-4fff-b10f-7e98b8b36df6" />


1. URL 간 우선순위를 두지 않는다. 페이지 순위, 사용자 트래픽 등 여러 척도를 두어 우선 순위를 구별하는게 좋을 것이다.

### 해결책 : 미수집 URL 저장소를 잘 구현하자 ( 큐 내부 )

<img width="752" height="395" alt="스크린샷 2025-08-20 오후 4 41 58" src="https://github.com/user-attachments/assets/c4564509-eab1-4588-bc9d-678ad0a6f95a" />

- 큐 라우터 : 같은 호스트에 속한 URL은 같은 큐에 가도록 보장한다.
- 큐 선택기 : 큐를 순회하며 큐에서 URL을 꺼내 지정된 작업 쓰레드에 전달한다.
- 작업 쓰레드 : 각 작업 쓰레드는 전달된 URL을 다운로드하고 작업들 사이엔 일정 지연시간을 둔다.

### 신선도

웹 페이지는 수시로 변경되기에, 이미 다운한 페이지더라도 주기적으로 재수집해야한다. 이때 웹 페이지의 변경 이력이나, 중요 페이지를 좀 더 자주 재수집하는 과정이 필요하다.

### 지속성 저장장치

처리해야하는 URL의 수는 수억개에 달하기에 모두 메모리에 보관하는것은 안정성이나 규모 확장성 측면에서 바람직하지 않다. 전부를 디스크에 저장하면, 느려서 병목 지점이 될 수 있다.

대부분의 URL을 디스크에 두고, IO 비용을 줄이기 위해 메모리 버퍼에 큐를 두어 큐에 둔 데이터를 주기적으로 디스크에 기록하는 대안을 선택할 수 있다. 

### HTML 다운로더에 사용할 수 있는 성능 최적화와 안정성을 위한 기법들

1. 분산 크롤링 - 성능을 높이기 위해 크롤링 작업을 여러 서버에 분산
2. DNS 조회 결과로 얻은 도메인 이름과 IP 주소의 관계를 캐시에 보관하고 크론 잡등을 돌려 주기적으로 갱신한다. 
3. 크롤링 작업을 수행하는 서버와 대상 서버를 지역별로 묶기
4. 짧은 타임 아웃
5. 다운로드 서버를 쉽게 추가하고 삭제하기 위한 안정 해시
6. 쉽게 복구할 수 있도록 크롤링 상태와 수집 데이터의 지속적 저장
7. 예외 처리와 데이터 검증

### 문제 있는 콘텐츠 감지 및 회피

1. 웹 콘텐츠 30% 가량은 중복이다. 체크섬을 사용하여 중복 콘텐츠를 탐지한다.
2. spidertrapexample.com/foo/bar/foo/bar…. 와 같이 무한히 깊은 디렉토리 구조는 크롤러를 무한 루프에 빠뜨린다. 이를 해결하기 위해 알고리즘을 개발하긴 까다롭기에 수작업이 필요하다.
3. 광고나 스팸 url 등은 가능하면 제외한다. 

### UUID 와 멱등키

멱등성 : 연산을 여러 번 해도 결과가 달라지지 않는 성질

### API 관점에서 멱등성 바라보기

멱등성이 보장된 API 란?

- 같은 요청이 여러 번 일어나도 서버에 동일한 효과를 미치는 API

**멱등성이 보장되지 않는 메소드** `POST` 

- post 요청을 보내는대로 서버의 상태는 달라진다.

### 멱등성을 보장하려면 멱등키를  API 요청에 포함하면 된다.

<img width="1005" height="286" alt="스크린샷 2025-08-20 오후 4 22 32" src="https://github.com/user-attachments/assets/fb64b493-34bf-4bff-8743-eda619ca587a" />

유저가 결제를 취소하려고 할때 요청에 멱등키를 포함한다면 ?

1. API 서버는 취소 요청마다 헤더에서 멱등키가 있는지 확인
2. 멱등키를 저장하기 위한 DB를 두어, 헤더에서 확인한 멱등키가 DB에 존재하는지 확인
3. 이전에 같은 멱등키로 들어온 요청이 있었으면 저장해둔 응답을 반환
4. 멱등키와 매칭되는 값이 없다면 새로 응답을 생성해서 반환

이때 사용되는 멱등키는 충분히 무작위적인 고유 값 UUID 다.

중복된 멱등키를 갖는 요청은 도메인 서버에서 도달하기 전에 차단되기에 API 성능 개선에 도움이 된다.

<img width="916" height="425" alt="스크린샷 2025-08-20 오후 4 25 38" src="https://github.com/user-attachments/assets/7b4667d3-a49b-441d-87e5-de1e1776ff63" />

<img width="722" height="567" alt="스크린샷 2025-08-20 오후 4 32 42 (1)" src="https://github.com/user-attachments/assets/14fd2e52-563e-4810-b7ea-166fd35e55c5" />

